{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nvar __jsx = React.createElement;\nimport React from 'react';\nexport function createCtxWithReducer(reducer, initialState) {\n  var defaultDispatch = function defaultDispatch() {\n    return initialState;\n  };\n\n  var stateCtx = React.createContext(initialState);\n  var dispatchCtx = React.createContext(defaultDispatch);\n\n  function useStateCtx(property) {\n    var state = React.useContext(stateCtx);\n\n    if (state === undefined) {\n      throw new Error('useCountState must be used within a CountProvider');\n    }\n\n    return state[property]; // only one depth selector for comparison\n  }\n\n  function useDispatchCtx() {\n    var context = React.useContext(dispatchCtx);\n\n    if (context === undefined) {\n      throw new Error('useCountDispatch must be used within a CountProvider');\n    }\n\n    return context;\n  }\n\n  function Provider(_ref) {\n    var children = _ref.children;\n\n    var _React$useReducer = React.useReducer(reducer, initialState),\n        _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n        state = _React$useReducer2[0],\n        dispatch = _React$useReducer2[1];\n\n    return __jsx(dispatchCtx.Provider, {\n      value: dispatch\n    }, __jsx(stateCtx.Provider, {\n      value: state\n    }, children));\n  } // return [ctx, Provider] as const;\n\n\n  return [useStateCtx, useDispatchCtx, Provider];\n} // create context with no upfront defaultValue\n// without having to do undefined check all the time\n\nexport function createCtx() {\n  var ctx = React.createContext(undefined);\n\n  function useCtx() {\n    var c = React.useContext(ctx);\n    if (!c) throw new Error('useCtx must be inside a Provider with a value');\n    return c;\n  }\n\n  return [useCtx, ctx.Provider]; // make TypeScript infer a tuple, not an array of union types\n}","map":null,"metadata":{},"sourceType":"module"}