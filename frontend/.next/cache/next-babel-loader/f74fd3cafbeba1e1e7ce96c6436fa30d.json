{"ast":null,"code":"var __jsx = React.createElement;\nimport React from 'react';\nexport function createCtxWithReducer(reducer, initialState) {\n  const defaultDispatch = () => initialState;\n\n  const stateCtx = React.createContext(initialState);\n  const dispatchCtx = React.createContext(defaultDispatch);\n\n  function useStateCtx(property) {\n    const state = React.useContext(stateCtx);\n\n    if (state === undefined) {\n      throw new Error('useCountState must be used within a CountProvider');\n    }\n\n    return state[property]; // only one depth selector for comparison\n  }\n\n  function useDispatchCtx() {\n    const context = React.useContext(dispatchCtx);\n\n    if (context === undefined) {\n      throw new Error('useCountDispatch must be used within a CountProvider');\n    }\n\n    return context;\n  }\n\n  function Provider({\n    children\n  }) {\n    const [state, dispatch] = React.useReducer(reducer, initialState);\n    return __jsx(dispatchCtx.Provider, {\n      value: dispatch\n    }, __jsx(stateCtx.Provider, {\n      value: state\n    }, children));\n  } // return [ctx, Provider] as const;\n\n\n  return [useStateCtx, useDispatchCtx, Provider];\n} // create context with no upfront defaultValue\n// without having to do undefined check all the time\n\nexport function createCtx() {\n  const ctx = React.createContext(undefined);\n\n  function useCtx() {\n    const c = React.useContext(ctx);\n    if (!c) throw new Error('useCtx must be inside a Provider with a value');\n    return c;\n  }\n\n  return [useCtx, ctx.Provider]; // make TypeScript infer a tuple, not an array of union types\n}","map":null,"metadata":{},"sourceType":"module"}